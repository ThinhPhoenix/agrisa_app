import { useAgrisaColors } from "@/domains/agrisa_theme/hooks/useAgrisaColor";
import { useAuthStore } from "@/domains/auth/stores/auth.store";
import { useSettingsStore } from "@/domains/shared/stores/settingsStore";
import { secureStorage } from "@/domains/shared/utils/secureStorage";
import {
  Box,
  Divider,
  HStack,
  Pressable,
  ScrollView,
  Switch,
  Text,
  VStack,
} from "@gluestack-ui/themed";
import * as LocalAuthentication from "expo-local-authentication";
import { useFocusEffect, useRouter } from "expo-router";
import {
  Bell,
  ChevronRight,
  CloudRain,
  FileText,
  Fingerprint,
  Key,
  Lock,
  ScanFace,
  Settings as SettingsIcon,
  Shield,
  Smartphone,
  Sprout,
} from "lucide-react-native";
import { useCallback, useEffect, useState } from "react";
import { Alert, Platform } from "react-native";
import { BiometricPasswordModal } from "./BiometricPasswordModal";

export default function SettingsScreen() {
  const { colors } = useAgrisaColors();
  const router = useRouter();
  const { notifications, toggleNotification } = useSettingsStore();

  const { user, refreshAuth, enableBiometric, disableBiometric } =
    useAuthStore();

  const [biometricType, setBiometricType] = useState<string>("Face ID");
  const [hasBiometric, setHasBiometric] = useState(false);
  const [isBiometricEnabledForAccount, setIsBiometricEnabledForAccount] =
    useState(false);
  const [isLoadingUser, setIsLoadingUser] = useState(true);

  // ‚úÖ State cho custom modal (Android)
  const [showPasswordModal, setShowPasswordModal] = useState(false);

  // ============================================
  // üîÑ REFRESH USER DATA KHI V√ÄO SCREEN
  // ============================================
  useFocusEffect(
    useCallback(() => {
      console.log("üîÑ [Settings] Screen focused, refreshing user data...");
      loadUserData();
    }, [])
  );

  const loadUserData = async () => {
    try {
      setIsLoadingUser(true);
      console.log("üì± [Settings] Loading user data...");

      // ‚úÖ Refresh auth t·ª´ SecureStore
      await refreshAuth();

      // ‚úÖ L·∫•y user m·ªõi nh·∫•t t·ª´ store
      const currentUser = useAuthStore.getState().user;
      console.log("üë§ [Settings] Current user after refresh:", currentUser);

      if (currentUser) {
        console.log("‚úÖ [Settings] User found:", {
          id: currentUser.id,
          email: currentUser.email,
          phone: currentUser.phone_number,
        });
      } else {
        console.log("‚ö†Ô∏è [Settings] No user found after refresh");
      }
    } catch (error) {
      console.error("‚ùå [Settings] Error loading user data:", error);
    } finally {
      setIsLoadingUser(false);
    }
  };

  // ============================================
  // üîç CHECK BIOMETRIC AVAILABILITY & STATUS
  // ============================================
  useEffect(() => {
    checkBiometricAvailability();
  }, []);

  useEffect(() => {
    if (user && !isLoadingUser) {
      console.log("‚úÖ [Settings] User available, checking biometric status");
      checkBiometricStatus();
    }
  }, [user, isLoadingUser]);

  const checkBiometricAvailability = async () => {
    try {
      const compatible = await LocalAuthentication.hasHardwareAsync();
      const enrolled = await LocalAuthentication.isEnrolledAsync();
      setHasBiometric(compatible && enrolled);

      console.log("üì± [Settings] Biometric hardware check:", {
        compatible,
        enrolled,
        available: compatible && enrolled,
      });

      if (compatible) {
        const types =
          await LocalAuthentication.supportedAuthenticationTypesAsync();
        if (
          types.includes(
            LocalAuthentication.AuthenticationType.FACIAL_RECOGNITION
          )
        ) {
          setBiometricType("Face ID");
        } else if (
          types.includes(LocalAuthentication.AuthenticationType.FINGERPRINT)
        ) {
          setBiometricType("V√¢n tay");
        } else {
          setBiometricType("Sinh tr·∫Øc h·ªçc");
        }
      }
    } catch (error) {
      console.error("‚ùå [Settings] L·ªói check biometric:", error);
    }
  };

  const checkBiometricStatus = async () => {
    try {
      if (!user) {
        console.log("‚ö†Ô∏è [Settings] No user found in checkBiometricStatus");
        return;
      }

      const identifier = user.email || user.phone_number;
      if (!identifier) {
        console.log("‚ö†Ô∏è [Settings] No identifier found");
        return;
      }

      // ‚úÖ L·∫•y device ID ƒë·ªÉ debug
      const deviceId = await secureStorage.getDeviceId();
      console.log("üì± [Settings] Device ID:", deviceId);
      console.log(
        "üë§ [Settings] Checking biometric for identifier:",
        identifier
      );

      const enabled = await secureStorage.isBiometricEnabled(identifier);
      setIsBiometricEnabledForAccount(enabled);

      console.log(`‚úÖ [Settings] Biometric status for ${identifier}:`, enabled);

      // ‚úÖ Ki·ªÉm tra password c√≥ t·ªìn t·∫°i kh√¥ng
      const hasPassword = await secureStorage.getBiometricPassword(identifier);
      console.log(`üîë [Settings] Has saved password:`, !!hasPassword);
    } catch (error) {
      console.error("‚ùå [Settings] Error checking biometric status:", error);
    }
  };

  // ============================================
  // üéØ HANDLERS
  // ============================================

  /**
   * ‚úÖ X·ª≠ l√Ω enable biometric sau khi nh·∫≠p password
   */
  const handleEnableBiometricWithPassword = async (password: string) => {
    console.log("üîë [Settings] Password received, length:", password?.length);

    if (!password) {
      console.log("‚ö†Ô∏è [Settings] Empty password");
      Alert.alert("L·ªói", "Vui l√≤ng nh·∫≠p m·∫≠t kh·∫©u");
      return;
    }

    try {
      console.log("üëÜ [Settings] Requesting biometric authentication...");

      // X√°c th·ª±c biometric tr∆∞·ªõc
      const result = await LocalAuthentication.authenticateAsync({
        promptMessage: `ƒêƒÉng nh·∫≠p b·∫±ng ${biometricType}`,
        fallbackLabel: "H·ªßy",
      });

      console.log("üëÜ [Settings] Biometric auth result:", result.success);

      if (result.success) {
        console.log("‚úÖ [Settings] Calling enableBiometric...");

        // Enable biometric trong auth store
        await enableBiometric(password);

        // C·∫≠p nh·∫≠t UI state
        setIsBiometricEnabledForAccount(true);

        const identifier = user!.email || user!.phone_number;
        const verified = await secureStorage.isBiometricEnabled(identifier!);
        console.log(
          "‚úÖ [Settings] Biometric enabled successfully, verified:",
          verified
        );

        Alert.alert("Th√†nh c√¥ng", `ƒê√£ b·∫≠t x√°c th·ª±c ${biometricType}`);
      } else {
        console.log("‚ùå [Settings] Biometric authentication failed");
        Alert.alert("Th·∫•t b·∫°i", "X√°c th·ª±c kh√¥ng th√†nh c√¥ng");
      }
    } catch (error: any) {
      console.error("‚ùå [Settings] Error enabling biometric:", error);
      console.error("‚ùå [Settings] Error details:", {
        message: error.message,
        code: error.code,
        stack: error.stack,
      });

      Alert.alert(
        "L·ªói",
        error.message || "Kh√¥ng th·ªÉ k√≠ch ho·∫°t " + biometricType
      );
    }
  };

  const handleToggleBiometric = async () => {
    console.log("üîÑ [Settings] Toggle biometric called");
    console.log("üë§ [Settings] Current user state:", user);

    if (!hasBiometric) {
      console.log("‚ö†Ô∏è [Settings] No biometric hardware available");
      Alert.alert(
        "Ch∆∞a thi·∫øt l·∫≠p",
        `Vui l√≤ng thi·∫øt l·∫≠p ${biometricType} tr√™n thi·∫øt b·ªã c·ªßa b·∫°n tr∆∞·ªõc.`,
        [{ text: "OK" }]
      );
      return;
    }

    if (!user) {
      console.log("‚ö†Ô∏è [Settings] No user logged in");
      console.log("üîÑ [Settings] Attempting to refresh user data...");

      // ‚úÖ Th·ª≠ refresh l·∫°i user
      await loadUserData();

      const currentUser = useAuthStore.getState().user;
      if (!currentUser) {
        Alert.alert(
          "L·ªói",
          "Kh√¥ng t√¨m th·∫•y th√¥ng tin ng∆∞·ªùi d√πng. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.",
          [
            {
              text: "ƒêƒÉng nh·∫≠p",
              onPress: () => router.push("/auth/sign-in"),
            },
          ]
        );
        return;
      }
    }

    const identifier = user!.email || user!.phone_number;
    console.log("üë§ [Settings] User identifier:", identifier);
    console.log(
      "üì± [Settings] Current biometric status:",
      isBiometricEnabledForAccount
    );

    if (!isBiometricEnabledForAccount) {
      // ‚úÖ B·∫¨T BIOMETRIC
      console.log("üîì [Settings] Enabling biometric...");

      // ‚úÖ Ph√¢n bi·ªát iOS vs Android
      if (Platform.OS === "ios") {
        // iOS: D√πng Alert.prompt
        Alert.prompt(
          "K√≠ch ho·∫°t " + biometricType,
          "Nh·∫≠p m·∫≠t kh·∫©u c·ªßa b·∫°n ƒë·ªÉ k√≠ch ho·∫°t ƒëƒÉng nh·∫≠p b·∫±ng " + biometricType,
          [
            {
              text: "H·ªßy",
              style: "cancel",
              onPress: () => console.log("‚ùå [Settings] User cancelled"),
            },
            {
              text: "X√°c nh·∫≠n",
              onPress: handleEnableBiometricWithPassword,
            },
          ],
          "secure-text"
        );
      } else {
        // Android: D√πng custom modal
        console.log("üì± [Settings] Opening password modal for Android");
        setShowPasswordModal(true);
      }
    } else {
      // ‚úÖ T·∫ÆT BIOMETRIC
      console.log("üîí [Settings] Disabling biometric...");

      Alert.alert(
        "T·∫Øt " + biometricType,
        `B·∫°n c√≥ ch·∫Øc mu·ªën t·∫Øt ƒëƒÉng nh·∫≠p b·∫±ng ${biometricType}?`,
        [
          {
            text: "H·ªßy",
            style: "cancel",
            onPress: () => console.log("‚ùå [Settings] User cancelled disable"),
          },
          {
            text: "T·∫Øt",
            style: "destructive",
            onPress: async () => {
              try {
                console.log("üîí [Settings] Calling disableBiometric...");

                // Disable biometric trong auth store
                await disableBiometric();

                // C·∫≠p nh·∫≠t UI state
                setIsBiometricEnabledForAccount(false);

                // Verify ngay
                const verified = await secureStorage.isBiometricEnabled(
                  identifier!
                );
                console.log(
                  "‚úÖ [Settings] Biometric disabled successfully, verified:",
                  verified
                );

                Alert.alert("ƒê√£ t·∫Øt", `${biometricType} ƒë√£ ƒë∆∞·ª£c t·∫Øt`);
              } catch (error) {
                console.error(
                  "‚ùå [Settings] Error disabling biometric:",
                  error
                );
                Alert.alert("L·ªói", "Kh√¥ng th·ªÉ t·∫Øt " + biometricType);
              }
            },
          },
        ]
      );
    }
  };

  const handleChangePassword = () => {
    router.push("/settings/change-password");
  };

  const handleVerifyIdentity = () => {
    router.push("/settings/verify-identity");
  };

  // ============================================
  // üé® RENDER HELPERS
  // ============================================
  const renderSectionHeader = (title: string, icon: any) => {
    const IconComponent = icon;
    return (
      <HStack space="sm" alignItems="center" mb="$3" mt="$2">
        <IconComponent size={20} color={colors.text} />
        <Text fontSize="$md" fontWeight="$bold" color={colors.text}>
          {title}
        </Text>
      </HStack>
    );
  };

  const renderSwitchItem = (
    label: string,
    value: boolean,
    onToggle: () => void,
    icon: any,
    disabled?: boolean
  ) => {
    const IconComponent = icon;
    return (
      <Pressable onPress={disabled ? undefined : onToggle} disabled={disabled}>
        <HStack
          p="$4"
          bg={colors.card}
          borderRadius="$lg"
          justifyContent="space-between"
          alignItems="center"
          mb="$2"
          opacity={disabled ? 0.5 : 1}
        >
          <HStack space="md" alignItems="center" flex={1}>
            <Box bg={colors.surface} p="$2" borderRadius="$md">
              <IconComponent size={20} color={colors.textSecondary} />
            </Box>
            <Text
              fontSize="$sm"
              fontWeight="$medium"
              color={colors.text}
              flex={1}
            >
              {label}
            </Text>
          </HStack>
          <Box>
            <Switch
              value={value}
              onValueChange={onToggle}
              size="sm"
              disabled={disabled}
            />
          </Box>
        </HStack>
      </Pressable>
    );
  };

  const renderNavigationItem = (
    label: string,
    onPress: () => void,
    icon: any
  ) => {
    const IconComponent = icon;
    return (
      <Pressable onPress={onPress}>
        <HStack
          p="$4"
          bg={colors.card}
          borderRadius="$lg"
          justifyContent="space-between"
          alignItems="center"
          mb="$2"
        >
          <HStack space="md" alignItems="center" flex={1}>
            <Box bg={colors.surface} p="$2" borderRadius="$md">
              <IconComponent size={20} color={colors.text} />
            </Box>
            <Text
              fontSize="$sm"
              fontWeight="$medium"
              color={colors.text}
              flex={1}
            >
              {label}
            </Text>
          </HStack>
          <ChevronRight size={20} color={colors.textSecondary} />
        </HStack>
      </Pressable>
    );
  };

  // ============================================
  // üé¨ RENDER
  // ============================================

  // ‚úÖ Show loading state
  if (isLoadingUser) {
    return (
      <Box
        flex={1}
        justifyContent="center"
        alignItems="center"
        bg={colors.background}
      >
        <Text fontSize="$lg" color={colors.textMuted}>
          ƒêang t·∫£i th√¥ng tin...
        </Text>
      </Box>
    );
  }

  return (
    <>
      <ScrollView
        bg={colors.background}
        showsVerticalScrollIndicator={false}
        showsHorizontalScrollIndicator={false}
      >
        <VStack p="$5" pb="$8" space="lg">
          {/* ============================================ */}
          {/* üîê B·∫¢O M·∫¨T */}
          {/* ============================================ */}
          <Box>
            {renderSectionHeader("B·∫£o m·∫≠t", Shield)}

            <VStack space="xs">
              {/* ƒê·ªïi m·∫≠t kh·∫©u */}
              {renderNavigationItem("ƒê·ªïi m·∫≠t kh·∫©u", handleChangePassword, Key)}

              {/* X√°c th·ª±c sinh tr·∫Øc h·ªçc */}
              {renderSwitchItem(
                `ƒêƒÉng nh·∫≠p b·∫±ng ${biometricType}`,
                isBiometricEnabledForAccount,
                handleToggleBiometric,
                biometricType === "Face ID" ? ScanFace : Fingerprint,
                !hasBiometric
              )}

              {/* X√°c th·ª±c danh t√≠nh (eKYC) */}
              {renderNavigationItem(
                "X√°c th·ª±c danh t√≠nh",
                handleVerifyIdentity,
                Lock
              )}
            </VStack>
          </Box>

          <Divider bg={colors.border} />

          {/* ============================================ */}
          {/* üîî TH√îNG B√ÅO */}
          {/* ============================================ */}
          <Box>
            {renderSectionHeader("Th√¥ng b√°o chung", Bell)}

            <VStack space="xs">
              {/* Th√¥ng b√°o th·ªùi ti·∫øt */}
              {renderSwitchItem(
                "D·ª± b√°o th·ªùi ti·∫øt",
                notifications.weather,
                () => toggleNotification("weather"),
                CloudRain
              )}

              {/* Th√¥ng b√°o t√¨nh tr·∫°ng th·ª≠a ru·ªông */}
              {renderSwitchItem(
                "T√¨nh tr·∫°ng th·ª≠a ru·ªông",
                notifications.farmStatus,
                () => toggleNotification("farmStatus"),
                Sprout
              )}

              {/* Th√¥ng b√°o y√™u c·∫ßu b·ªìi th∆∞·ªùng */}
              {renderSwitchItem(
                "Y√™u c·∫ßu b·ªìi th∆∞·ªùng",
                notifications.claims,
                () => toggleNotification("claims"),
                FileText
              )}

              {/* Th√¥ng b√°o h·ªá th·ªëng */}
              {renderSwitchItem(
                "Th√¥ng b√°o h·ªá th·ªëng",
                notifications.system,
                () => toggleNotification("system"),
                SettingsIcon
              )}
            </VStack>
          </Box>
        </VStack>
      </ScrollView>

      {/* ‚úÖ Custom Password Modal cho Android */}
      <BiometricPasswordModal
        isOpen={showPasswordModal}
        onClose={() => setShowPasswordModal(false)}
        onConfirm={(password) => {
          setShowPasswordModal(false);
          handleEnableBiometricWithPassword(password);
        }}
        biometricType={biometricType}
      />
    </>
  );
}
